{"No":"ORR27",
"Subject":"스레드를 종료하고자 Thread.stop()메서드를 사용하지 않는다",
"Level":"Low",
"Description":"정상적으로 스레드가 종료하게 되면 클래스는 불변의 성질을 유지하게 된다. 하지만 Thread.stop()메서드를 호출하면 스레드가 가지고 있던 모든 락이 해제되어 락이 보호하고 있던 객체를 노출하게 된다.\n 결과적으로 객체는 일관성 없는 상태가 된다.  뿐만 아니라 이 method는 폐지될 예정이다. 그러므로 Thread.stop()을 호출해서는 안 된다.",
"VulnCode":"public final class Container implements Runnable {\n\tpriavte final Vector<Integer> vector = new Vector<Integer>(1000);\n\tpublic Vector<Integer> getVector() {\n\t\treturn vector;\n\t}\n\t@Override public synchronized void run() {\n\t\tRandom number = new Random(123L);\n\t\tint i = vector.capacity();\n\t\twhile(i>0){\n\t\t\tvector.add(number.nextInt(100));\n\t\t\ti--;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tTherad thread = new Thread(new Container());\n\t\tthread.start();\n\t\tthread.sleep(5000);\n\t\tthread.stop();\n\t}\n}",
"SecuCode":"public final class Container implements Runnable {\n\tprivate final Vector<Integer> vector = new Vector<Integer>(1000);\n\tprivate volatile boolean done = false;\n\tpublic Vector<Integer> getVector() {\n\t\treturn vector;\n\t}\n\n\tpublic void shutdown() {\n\t\tdone = true;\n\t}\n\t@Override public synchronized void run() {\n\t\tRandom number = new Random(123L);\n\t\tint i = vector.capacity();\n\t\twhile(i>0){\n\t\t\tvector.add(number.nextInt(100));\n\t\t\ti--;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tContainer container = new Container();\n\t\tTherad thread = new Thread(container);\n\t\tthread.start();\n\t\tthread.sleep(5000);\n\t\tthread.stop();\n\t\tcontainer.shutdown();\n\t}\n}"}