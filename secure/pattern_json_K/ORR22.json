{"No":"ORR22",
"Subject":"클래스를 수정할 때는 직렬화 호환성을 유지한다.",
"Level":"Low",
"Description":"클래스를 바꾸게 되면 사용자가 이전 클래스로 만든 직렬화된 바이트 스트림은 새로운 클래스와 호환되지 않는다.\n그러므로 클래스를 수정할 때 프로그램이 반드시 직렬화 호환성을 유지해야 한다. 사용자 정의 직렬화가 가장 적절한 방법이다.",
"Vulncode":"Class [class 명] implements Serializable {\n\tint [var] = [value];\n\n\tpublic String [method](){\n\t\treturn String.valueOf([var]);\n\t}\n}",
"Secucode":"1)\nclass [class 명] implements Serializable {\n\tprivate static final long serialVersionUID = [숫자]L;\n\n\tint [var] = [value];\n\n\tpublic String [method](){\n\t\treturn String.valueOf([var]);\n\t}\n}\n\n\n2)\nclass [class_1] implements Serializable {\n\tint [var1] = [value];\n}\npublic class [class_2] implements Serializable {\n\t[class_1] [obj] = new [class_1]();\n\tprivate static final ObjectStreamField[] serialPersistentFields\n\t\t\t= {new OjbectStreamFiled(\"[obj]\", [class_1].class)};\n\n\tprivate void [method1](ObjectInputStream [param]) throws IOException {\n\t\ttry {\n\t\t\tObjectInputStream.GetField [var2] = [param].readFields();\n\t\t\tthis.[obj] = ([class_1]) [var2].get(\"[obj]\", [obj]);\n\t\t} catch (ClassNotFoundException [exception]) {\n\t\t\t...\n\t\t}\n\t}\n\tprivate void [method2](ObjectOutputStream [param]) throws IOException {\n\t\tObjectOutputStream.PutField [var3] = [param].putFields();\n\t\t[var3].put(\"[obj]\", [obj]);\n\t\t[param].writeFields();\n\t}\n\n\tpublic String [method3](){\n\t\treturn String.valueOf([obj]);\n\t}\n}"}