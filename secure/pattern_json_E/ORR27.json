{"No":"ORR27",
"Subject":"Do not use Thread.stop() to terminate threads",
"Level":"Low",
"Description":"Threads preserve class invariants when they are allowed to exit normally. Invoking Thread.stop() results in the release of all locks a thread has acquired, potentially exposing the objects protected by those locks when those objects are in an inconsistent state. \n  Furthermore, this method is deprecated. So do not use Thread.stop().",
"VulnCode":"public final class Container implements Runnable {\n\tpriavte final Vector<Integer> vector = new Vector<Integer>(1000);\n\tpublic Vector<Integer> getVector() {\n\t\treturn vector;\n\t}\n\t@Override public synchronized void run() {\n\t\tRandom number = new Random(123L);\n\t\tint i = vector.capacity();\n\t\twhile(i>0){\n\t\t\tvector.add(number.nextInt(100));\n\t\t\ti--;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tTherad thread = new Thread(new Container());\n\t\tthread.start();\n\t\tthread.sleep(5000);\n\t\tthread.stop();\n\t}\n}",
"SecuCode":"public final class Container implements Runnable {\n\tprivate final Vector<Integer> vector = new Vector<Integer>(1000);\n\tprivate volatile boolean done = false;\n\tpublic Vector<Integer> getVector() {\n\t\treturn vector;\n\t}\n\n\tpublic void shutdown() {\n\t\tdone = true;\n\t}\n\t@Override public synchronized void run() {\n\t\tRandom number = new Random(123L);\n\t\tint i = vector.capacity();\n\t\twhile(i>0){\n\t\t\tvector.add(number.nextInt(100));\n\t\t\ti--;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tContainer container = new Container();\n\t\tTherad thread = new Thread(container);\n\t\tthread.start();\n\t\tthread.sleep(5000);\n\t\tthread.stop();\n\t\tcontainer.shutdown();\n\t}\n}"}